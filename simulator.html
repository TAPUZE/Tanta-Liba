<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Epoxy Mezuzah Simulator - PNG Elements</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #f0f0f0; /* Light gray background */
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        canvas {
            display: block; /* Prevent extra space below canvas */
        }
        /* Info box styling */
        #info {
            position: absolute;
            bottom: 10px; /* Move info box to bottom */
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 100;
        }
        /* Ensure lil-gui is visible */
        .lil-gui {
             z-index: 101 !important; /* Make sure GUI is on top */
             font-size: 14px; /* Adjust font size if needed */
             max-height: 90vh; /* Prevent GUI from being too tall */
             overflow-y: auto; /* Allow scrolling if needed */
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="container"></div>
    <div id="info">Drag mouse to rotate, scroll to zoom</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <script type="module">
        // Import necessary modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import GUI from 'lil-gui';

        // --- Module Scope Variables ---
        let scene, camera, renderer, controls;
        let mezuzahGroup, elementsGroup, shinGroup; // Main groups
        let wheatGroup, leafGroup, pebblesGroup, sandGroup; // Sub-groups for elements
        let mezuzahMesh, shinMaterial; // Controlled meshes/materials
        let gui; // GUI instance
        let textureLoader; // Texture loader instance

        // --- Textures ---
        // Using local PNG files - Make sure wheat.png, leaf.png, pebble.png exist in the same folder
        const textures = {
            wheat: './wheat.png', // Local wheat image
            leaf: './leaf.png',   // Local leaf image
            pebble: './pebble.png', // Local pebble image
            sand_colors: [ // Using placeholder textures for sand color variation
                'https://placehold.co/16x16/FFD700/ccad00?text=.', // Gold
                'https://placehold.co/16x16/ADD8E6/87ceeb?text=.', // Light Blue
                'https://placehold.co/16x16/FFA07A/e9967a?text=.', // Light Salmon
                'https://placehold.co/16x16/F5F5DC/dcdcdc?text=.'  // Beige
            ]
        };
        const loadedTextures = {}; // Cache for loaded textures

        // --- Control Parameters ---
        const params = {
            // Epoxy Material adjustments
            epoxyColor: 0xFAFAFF,
            epoxyOpacity: 0.85,
            epoxyRoughness: 0.05,
            epoxyIOR: 1.45,

            shinColor: 0x444444,

            // Wheat Controls
            wheatVisible: true,
            wheatSize: 3.0, // Scaler for the base size
            wheatPosX: -0.3, wheatPosY: -2.0, wheatPosZ: 0.0,

            // Leaf Controls
            leafVisible: true,
            leafSize: 1.5, // Scaler for the base size
            leafPosX: 0.3, leafPosY: 1.0, leafPosZ: 0.1,

            // Pebble Controls - Using PlaneGeometry with PNG texture
            pebbleVisible: true,
            pebbleCount: 25,
            pebbleSize: 0.25, // Base size for the pebble plane
            pebbleRoughness: 0.7, // Material roughness for the pebble plane
            pebbleSpread: 0.8,

            // Sand Controls
            sandVisible: true,
            sandCount: 150,
            sandGrainSize: 0.04,
            sandRoughness: 0.85,
            sandSpread: 0.9,

            regenerateElements: function() {
                updateAllElements();
            }
        };

        // --- Constants ---
        const mezuzahHeight = 10;
        const mezuzahWidth = 1.5;
        const mezuzahDepth = 1;
        const mezuzahRadius = Math.min(mezuzahWidth, mezuzahDepth) / 2 * 0.9;
        const mezuzahSegments = 5;
        const elementPadding = 0.1;

        // --- Initialization Function ---
        function init() {
            // 0. Texture Loader
            textureLoader = new THREE.TextureLoader();
            // Add error handling for local file loading
             textureLoader.onerror = (error) => {
                console.error("Texture loading error:", error);
                // Potentially display a user-friendly message on the page
             };
            preloadTextures();

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 12);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8);
            directionalLight.position.set(6, 12, 8);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x555555, 0.5 );
            hemiLight.position.set( 0, 20, 0 );
            scene.add( hemiLight );

            // 5. Controls Setup
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 3;
            controls.maxDistance = 40;
            controls.maxPolarAngle = Math.PI / 1.5;
            controls.target.set(0, 0, 0);
            controls.update();

            // 6. Create Mezuzah Groups
            mezuzahGroup = new THREE.Group();
            elementsGroup = new THREE.Group();
            shinGroup = new THREE.Group();
            mezuzahGroup.add(elementsGroup);
            mezuzahGroup.add(shinGroup);
            scene.add(mezuzahGroup);

            wheatGroup = new THREE.Group(); elementsGroup.add(wheatGroup);
            leafGroup = new THREE.Group(); elementsGroup.add(leafGroup);
            pebblesGroup = new THREE.Group(); elementsGroup.add(pebblesGroup);
            sandGroup = new THREE.Group(); elementsGroup.add(sandGroup);

            // 7. Create Mezuzah Body
            const geometry = new RoundedBoxGeometry(mezuzahWidth, mezuzahHeight, mezuzahDepth, mezuzahSegments, mezuzahRadius);
            const material = new THREE.MeshPhysicalMaterial({
                color: params.epoxyColor,
                metalness: 0.05,
                roughness: params.epoxyRoughness,
                transmission: 1.0,
                thickness: 1.0,
                ior: params.epoxyIOR,
                transparent: true,
                opacity: params.epoxyOpacity,
                side: THREE.DoubleSide,
            });
            mezuzahMesh = new THREE.Mesh(geometry, material);
            mezuzahMesh.castShadow = true;
            mezuzahMesh.receiveShadow = true;
            mezuzahGroup.add(mezuzahMesh);

            // 8. Create Shin Letter
            createShinLetter(mezuzahWidth, mezuzahHeight, mezuzahDepth, mezuzahRadius);

            // 9. Create Initial Embedded Elements
            updateAllElements();

            // 10. Add Ground Plane
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide, roughness: 0.8 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -mezuzahHeight / 2 - 0.1;
            plane.receiveShadow = true;
            scene.add(plane);

            // 11. Setup GUI Controls
            setupGUI();

            // 12. Handle Window Resize
            window.addEventListener('resize', onWindowResize, false);

            // 13. Start Animation Loop
            animate();
        }

        // --- Preload Textures ---
        function preloadTextures() {
            const onError = (url) => (err) => {
                console.error(`Error loading texture: ${url}`, err);
                // Add fallback logic here if needed, e.g., mark texture as failed
                // You could add a red box again or just skip the element.
                 alert(`Failed to load image: ${url}\nMake sure the file exists in the same folder as the HTML.`);
            };

            textureLoader.load(textures.wheat, (tex) => loadedTextures.wheat = tex, undefined, onError(textures.wheat));
            textureLoader.load(textures.leaf, (tex) => loadedTextures.leaf = tex, undefined, onError(textures.leaf));
            textureLoader.load(textures.pebble, (tex) => loadedTextures.pebble = tex, undefined, onError(textures.pebble)); // Load pebble texture

            loadedTextures.sand_colors = [];
            textures.sand_colors.forEach(url => {
                // Sand uses placeholders, less likely to fail, but keep error handler
                textureLoader.load(url, (tex) => loadedTextures.sand_colors.push(tex), undefined, onError(url));
            });
            console.log("Preloading textures (wheat, leaf, pebble from local files)...");
        }

        // --- Function to Setup GUI ---
        function setupGUI() {
            gui = new GUI();
            gui.title("Mezuzah Controls");

            // --- General & Epoxy Controls ---
            const generalFolder = gui.addFolder('General & Epoxy');
            generalFolder.addColor(params, 'epoxyColor').name('Epoxy Color')
                .onChange((value) => { mezuzahMesh.material.color.set(value); });
            generalFolder.add(params, 'epoxyOpacity', 0.1, 1.0, 0.01).name('Epoxy Opacity')
                .onChange((value) => { mezuzahMesh.material.opacity = value; });
            generalFolder.add(params, 'epoxyRoughness', 0.0, 0.5, 0.01).name('Epoxy Roughness')
                 .onChange((value) => { mezuzahMesh.material.roughness = value; });
             generalFolder.add(params, 'epoxyIOR', 1.0, 2.33, 0.01).name('Epoxy IOR')
                 .onChange((value) => { mezuzahMesh.material.ior = value; });
            generalFolder.addColor(params, 'shinColor').name('Shin Color')
                .onChange((value) => { if (shinMaterial) shinMaterial.color.set(value); });
            generalFolder.open();

            // --- Wheat Controls ---
            const wheatFolder = gui.addFolder('Wheat Stalk');
            wheatFolder.add(params, 'wheatVisible').name('Visible').onChange(updateAllElements);
            wheatFolder.add(params, 'wheatSize', 0.5, 5.0, 0.1).name('Size').onChange(updateAllElements);
            wheatFolder.add(params, 'wheatPosX', -mezuzahWidth/2, mezuzahWidth/2, 0.05).name('Position X').onChange(updateAllElements);
            wheatFolder.add(params, 'wheatPosY', -mezuzahHeight/2, mezuzahHeight/2, 0.1).name('Position Y').onChange(updateAllElements);
            wheatFolder.add(params, 'wheatPosZ', -mezuzahDepth/2, mezuzahDepth/2, 0.05).name('Position Z').onChange(updateAllElements);

            // --- Leaf Controls ---
            const leafFolder = gui.addFolder('Leaf');
            leafFolder.add(params, 'leafVisible').name('Visible').onChange(updateAllElements);
            leafFolder.add(params, 'leafSize', 0.5, 3.0, 0.1).name('Size').onChange(updateAllElements);
            leafFolder.add(params, 'leafPosX', -mezuzahWidth/2, mezuzahWidth/2, 0.05).name('Position X').onChange(updateAllElements);
            leafFolder.add(params, 'leafPosY', -mezuzahHeight/2, mezuzahHeight/2, 0.1).name('Position Y').onChange(updateAllElements);
            leafFolder.add(params, 'leafPosZ', -mezuzahDepth/2, mezuzahDepth/2, 0.05).name('Position Z').onChange(updateAllElements);

            // --- Pebble Controls (Using PNG Texture) ---
            const pebbleFolder = gui.addFolder('Pebbles');
            pebbleFolder.add(params, 'pebbleVisible').name('Visible').onChange(updateAllElements);
            pebbleFolder.add(params, 'pebbleCount', 0, 100, 1).name('Count').onChange(updateAllElements);
            pebbleFolder.add(params, 'pebbleSize', 0.05, 0.5, 0.01).name('Size').onChange(updateAllElements); // Size of the plane
            // Removed pebbleColor and sizeVariation controls
            pebbleFolder.add(params, 'pebbleRoughness', 0.0, 1.0, 0.05).name('Roughness').onChange(updateAllElements);
            pebbleFolder.add(params, 'pebbleSpread', 0.1, 1.0, 0.05).name('Spread').onChange(updateAllElements);

            // --- Sand Controls ---
            const sandFolder = gui.addFolder('Colorful Sand');
            sandFolder.add(params, 'sandVisible').name('Visible').onChange(updateAllElements);
            sandFolder.add(params, 'sandCount', 0, 500, 5).name('Count').onChange(updateAllElements);
            sandFolder.add(params, 'sandGrainSize', 0.01, 0.1, 0.005).name('Grain Size').onChange(updateAllElements);
             sandFolder.add(params, 'sandRoughness', 0.0, 1.0, 0.05).name('Roughness').onChange(updateAllElements);
            sandFolder.add(params, 'sandSpread', 0.1, 1.0, 0.05).name('Spread').onChange(updateAllElements);
        }

        // --- Function to Clear a Specific Group ---
        function clearGroup(group) {
            group.traverse(child => {
                if (child instanceof THREE.Mesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        // Only dispose map if it's unique per object, otherwise textures might be disposed prematurely
                        // if (child.material.map && !Object.values(loadedTextures).includes(child.material.map) && !loadedTextures.sand_colors.includes(child.material.map)) {
                        //    child.material.map.dispose();
                        // }
                        child.material.dispose();
                    }
                }
            });
            while (group.children.length > 0) {
                group.remove(group.children[0]);
            }
        }


        // --- Function to Update All Embedded Elements ---
        function updateAllElements() {
            clearGroup(wheatGroup);
            clearGroup(leafGroup);
            clearGroup(pebblesGroup);
            clearGroup(sandGroup);

            const innerWidth = mezuzahWidth - mezuzahRadius * 2 - elementPadding * 2;
            const innerHeight = mezuzahHeight - mezuzahRadius * 2 - elementPadding * 2;
            const innerDepth = mezuzahDepth - mezuzahRadius * 2 - elementPadding * 2;

            // --- Create Wheat --- (Using PlaneGeometry with wheat.png)
            if (params.wheatVisible && loadedTextures.wheat) {
                const texture = loadedTextures.wheat;
                // Use texture dimensions for aspect ratio if available
                const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1; // Default aspect ratio
                const baseHeight = 1.0;
                const planeHeight = baseHeight * params.wheatSize;
                const planeWidth = planeHeight * aspectRatio;
                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshStandardMaterial({
                    map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.1, // alphaTest helps with PNG transparency edges
                    roughness: 0.7, metalness: 0.1
                });
                const wheat = new THREE.Mesh(geometry, material);
                wheat.position.set(params.wheatPosX, params.wheatPosY, params.wheatPosZ);
                wheat.position.x = THREE.MathUtils.clamp(wheat.position.x, -innerWidth / 2, innerWidth / 2);
                wheat.position.y = THREE.MathUtils.clamp(wheat.position.y, -innerHeight / 2, innerHeight / 2);
                wheat.position.z = THREE.MathUtils.clamp(wheat.position.z, -innerDepth / 2, innerDepth / 2);
                wheat.castShadow = true;
                wheatGroup.add(wheat);
            } else if (params.wheatVisible) {
                 console.warn("Wheat texture not loaded, cannot create wheat element.");
            }

            // --- Create Leaf --- (Using PlaneGeometry with leaf.png)
            if (params.leafVisible && loadedTextures.leaf) {
                const texture = loadedTextures.leaf;
                const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                const baseWidth = 0.8;
                const planeWidth = baseWidth * params.leafSize;
                const planeHeight = planeWidth / aspectRatio;
                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshStandardMaterial({
                    map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.1,
                    roughness: 0.6, metalness: 0.05
                });
                const leaf = new THREE.Mesh(geometry, material);
                leaf.position.set(params.leafPosX, params.leafPosY, params.leafPosZ);
                leaf.position.x = THREE.MathUtils.clamp(leaf.position.x, -innerWidth / 2, innerWidth / 2);
                leaf.position.y = THREE.MathUtils.clamp(leaf.position.y, -innerHeight / 2, innerHeight / 2);
                leaf.position.z = THREE.MathUtils.clamp(leaf.position.z, -innerDepth / 2, innerDepth / 2);
                leaf.rotation.z = Math.PI / 8;
                leaf.castShadow = true;
                leafGroup.add(leaf);
             } else if (params.leafVisible) {
                 console.warn("Leaf texture not loaded, cannot create leaf element.");
            }

            // --- Create Pebbles --- (Using PlaneGeometry with pebble.png)
            if (params.pebbleVisible && loadedTextures.pebble && params.pebbleCount > 0) {
                const texture = loadedTextures.pebble;
                // Use texture aspect ratio if available, otherwise assume square
                 const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                 const planeWidth = aspectRatio >= 1 ? params.pebbleSize * aspectRatio : params.pebbleSize;
                 const planeHeight = aspectRatio < 1 ? params.pebbleSize / aspectRatio : params.pebbleSize;

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    transparent: true, // Assume pebble.png has transparency
                    side: THREE.DoubleSide,
                    alphaTest: 0.1,
                    roughness: params.pebbleRoughness,
                    metalness: 0.1
                });

                const spreadFactor = params.pebbleSpread;
                for (let i = 0; i < params.pebbleCount; i++) {
                    // Clone geometry, reuse material
                    const pebble = new THREE.Mesh(geometry.clone(), material);

                    // Random position within the spread area
                    pebble.position.x = (Math.random() - 0.5) * innerWidth * spreadFactor;
                    pebble.position.y = (Math.random() - 0.5) * innerHeight * spreadFactor;
                    pebble.position.z = (Math.random() - 0.5) * innerDepth * spreadFactor;

                    // Random rotation
                    pebble.rotation.x = Math.random() * Math.PI * 2;
                    pebble.rotation.y = Math.random() * Math.PI * 2;
                    pebble.rotation.z = Math.random() * Math.PI * 2;

                    pebble.castShadow = true;
                    // pebble.receiveShadow = true; // Less important for flat planes inside
                    pebblesGroup.add(pebble);
                }
                 // Dispose of the template geometry
                 geometry.dispose();
             } else if (params.pebbleVisible) {
                 console.warn("Pebble texture not loaded, cannot create pebble elements.");
            }


            // --- Create Sand --- (Remains the same, using placeholder textures)
            if (params.sandVisible && loadedTextures.sand_colors?.length > 0 && params.sandCount > 0) {
                const geometry = new THREE.PlaneGeometry(params.sandGrainSize, params.sandGrainSize);
                const sandMaterials = loadedTextures.sand_colors.map(texture => new THREE.MeshStandardMaterial({
                    map: texture,
                    transparent: false, side: THREE.DoubleSide,
                    roughness: params.sandRoughness,
                    metalness: 0.05
                }));

                if (sandMaterials.length === 0) return;

                const spreadFactor = params.sandSpread;
                for (let i = 0; i < params.sandCount; i++) {
                    const material = sandMaterials[Math.floor(Math.random() * sandMaterials.length)];
                    const sandGrain = new THREE.Mesh(geometry.clone(), material);

                    sandGrain.position.x = (Math.random() - 0.5) * innerWidth * spreadFactor;
                    sandGrain.position.y = (Math.random() - 0.5) * innerHeight * spreadFactor;
                    sandGrain.position.z = (Math.random() - 0.5) * innerDepth * spreadFactor;

                    sandGrain.rotation.x = Math.random() * Math.PI * 2;
                    sandGrain.rotation.y = Math.random() * Math.PI * 2;
                    sandGrain.rotation.z = Math.random() * Math.PI * 2;

                    sandGroup.add(sandGrain);
                }
                 geometry.dispose();
            }
        }


        // --- Function to Create Shin Letter ---
        function createShinLetter(mWidth, mHeight, mDepth, mRadius) {
             // Clear previous shin before recreating
            clearGroup(shinGroup); // Use clearGroup to handle disposal

            shinMaterial = new THREE.MeshStandardMaterial({ color: params.shinColor, roughness: 0.4, metalness: 0.2 });

            const barWidth = 0.1; const barHeight = 0.6; const barDepth = 0.1;
            const baseWidth = mWidth * 0.5;
            // Create geometries once
            const barGeometry = new THREE.BoxGeometry(barWidth, barHeight, barDepth);
            const baseGeometry = new THREE.BoxGeometry(baseWidth, barWidth, barDepth);
            const frontOffset = mDepth / 2 + barDepth / 2 + 0.01;
            const verticalPosition = mHeight * 0.3;

            // Create meshes reusing geometries and material
            const bar1 = new THREE.Mesh(barGeometry, shinMaterial);
            bar1.position.set(-baseWidth / 2 + barWidth / 2, verticalPosition, frontOffset);
            bar1.rotation.z = Math.PI / 18;

            const bar2 = new THREE.Mesh(barGeometry, shinMaterial);
            bar2.position.set(0, verticalPosition, frontOffset);

            const bar3 = new THREE.Mesh(barGeometry, shinMaterial);
            bar3.position.set(baseWidth / 2 - barWidth / 2, verticalPosition, frontOffset);
            bar3.rotation.z = -Math.PI / 18;

            const base = new THREE.Mesh(baseGeometry, shinMaterial);
            base.position.set(0, verticalPosition - barHeight / 2 + barWidth / 2, frontOffset);

            bar1.castShadow = true; bar2.castShadow = true; bar3.castShadow = true; base.castShadow = true;

            shinGroup.add(bar1); shinGroup.add(bar2); shinGroup.add(bar3); shinGroup.add(base);
        }

        // --- Handle Window Resize ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Start the application ---
        window.onload = function() {
            // Quick check if running locally without a server
            if (window.location.protocol === 'file:') {
                console.warn("Running from local 'file://' protocol. Loading local textures might be blocked by browser security settings. Consider using a simple local web server.");
                // Optionally display a message to the user in the #info div
                const infoDiv = document.getElementById('info');
                if(infoDiv) {
                    const warning = document.createElement('p');
                    warning.textContent = 'Warning: Local images might not load due to browser security. Use a local server.';
                    warning.style.color = 'yellow';
                    warning.style.marginTop = '5px';
                    infoDiv.appendChild(warning);
                }
            }
            init();
        };

    </script>

</body>
</html>
